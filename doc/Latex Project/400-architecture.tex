\chapter{Architecture}
\label{Architecture}
\thispagestyle{plain}

This project is meant to participate in the \gls{itc2007}. Comparing the approach and the results with the finalists of the competition is one of the main objectives of this project. Thus, it is ideal to develop an organized program with the best performance possible, so the implemented code can be easily understandable, extensible and so afford the best scores possible when creating timetable solutions. Taking that into account, this section is reserved to the description of the architecture and explanation of the most important decisions taken regarding this subject.

\section{System Architecture}

The architecture of this project is divided in multiple layers. These are independent from one another and each of them has its unique features considering the objectives of this project. The layers presented in the project are named \textit{\gls{dl}}, \textit{\gls{dal}}, \textit{\gls{bl}}, \textit{\gls{hl}}, \textit{\gls{tl}} and \textit{\gls{pl}}. \\

The assortment, dependencies and the main classes of each layer can be seen in \ref{fig:SystemArchitecture}.

\begin{figure}[t!]
\centering
\begin{tikzpicture}
\begin{umlpackage}[x = 4, y = 0]{Data Layer} 

\end{umlpackage}

\begin{umlpackage}[x = 0, y=-3]{Data Access Layer}
\begin{umlpackage}[x = -0.9]{Models}
\end{umlpackage}
\umlinterface[x = 3]{IRepository}{}{}
\umlclass[x = 6]{Repository}{}{}
\end{umlpackage}

\begin{umlpackage}[y=-6]{Business Layer} 
\umlclass[x = 0]{PeriodHardConstraints}{}{}
\umlclass[x = 3.5]{Solutions}{}{}
\umlclass[x = 6]{Periods}{}{}
\umlclass[x = 8.5]{ConflictMatrix}{}{}
\umlclass[x = 12]{ModelWeightings}{}{}
\umlclass[x = -0.7, y = -1.5]{Examinations}{}{}
\umlclass[x = 3, y = -1.5]{RoomHardConstraints}{}{}
\umlclass[x = 6, y = -1.5]{Rooms}{}{}
\end{umlpackage}

\begin{umlpackage}[x = -0.2, y=-10.5]{Heuristics Layer}
\umlclass[x = 0]{Simulated Annealing}{}{}
\umlclass[x = 3.7]{Graph Coloring}{}{}
\umlclass[x = -0.6, y = -1.5]{Hill Climbing}{}{}
\end{umlpackage}

\begin{umlpackage}[x = 7.5, y=-10.5]{Tools Layer}
\umlclass[x = -0.1]{NeighborSelection}{}{}
\umlclass[x = 2.55]{Loader}{}{}
\umlclass[x = 5.3]{OutputFormatting}{}{}
\umlclass[x = 0, y = -1.5]{EvaluationFunction}{}{}
\umlclass[x = 3.7, y = -1.5]{FeasibilityTester}{}{}
\end{umlpackage}

\begin{umlpackage}[x = 2.5,y = -15]{Presentation Layer}
\umlclass[x = 0]{GraphColoringTest}{}{}
\umlclass[x = 4]{SimulatedAnnealingTest}{}{}
\end{umlpackage}

\umlassoc[geometry=-|-, anchor1 = -139, anchor2 = 60]{Data Layer}{Data Access Layer}
\umlassoc[geometry=-|-, anchor1 = -37, anchor2 = 135]{Data Access Layer}{Business Layer}
\umlassoc[geometry=-|-, anchor1 = 37, anchor2 = -143]{Heuristics Layer}{Business Layer}
\umlassoc[geometry=-|-, anchor1 = 143, anchor2 = -37]{Tools Layer}{Business Layer}
\umlassoc[geometry=-|-, anchor1 = 18, anchor2 = -149]{Presentation Layer}{Tools Layer}
\umlassoc[geometry=-|-, anchor1 = 152, anchor2 = -44]{Presentation Layer}{Heuristics Layer}
\end{tikzpicture}

\caption{System Architecture} \label{fig:SystemArchitecture}
\end{figure}

\subsection{Data Layer}

The \gls{dl} is the layer where all entities are stored. Considering the fact that these entities must always be obtained from a file presented in \gls{itc2007}'s website \cite{McCollum2007a}, it does not make sense to keep these entities after the program runs. So, the entities are stored in volatile memory all the time and are discarded after the program is finished.

\subsection{Data Access Layer}

The \gls{dal} is the layer that allow access to the data stored in the \gls{dl} and provide the signatures of all entities. This layer provides repositories of each type of entity. The repository was implemented in a way that it's signature  is generic, and so can only be created with objects that implement IEntity. This is mandatory because the generic repository's implementation uses the identification presented in IEntity. \\

The Repository class stores the entities in a list, which index corresponds to the entity's identifier. The Repository provides basic CRUD functions to access and edit the entities stored. The signature of the entities and all the specifications of the generic repository can be seen in the \ref{fig:DataAccessLayer}.\\

\begin{figure}[t!]
\centering

\begin{tikzpicture}

\begin{umlpackage}[x = 0, y=-3]{Data Access Layer}
\begin{umlpackage}[x = -0.9]{Models}
\umlinterface[x = -10, y = 0]{IEntity}{}{}
\umlinterface[x = -10, y = -5.5]{ISolution}{}{}
\umlclass[x = -10, y = -7.5]{Solution}{}{}
\umlclass[x = -8, y = -5.5]{Period}{}{}
\umlclass[x = -5.7, y = -5.5]{Examination}{}{}
\umlclass[x = -3.5, y = -5.5]{Room}{}{}
\umlclass[x = -0.5, y = -4.5]{PeriodHardConstraint}{}{}
\umlclass[x = -0.5, y = -3]{RoomHardConstraint}{}{}
\umlclass[x = -1.2, y = -1.5]{InstitutionalModelWeightings}{}{}
\end{umlpackage}
\umlinterface[x = 3, y = 0]{IRepository<T>}
{}
{
	+Insert(entity : T) : void\\
	+Delete(entity : T) : void\\
	+GetAll() : IEnumerable<T>\\
	+GetById(id : int) : T\\
	+EntryCount() : int
}
\umlclass[x = 3, y = -5]{Repository<T>}
{
	\#list : List<T>
}
{
	+Insert(entity : T) : void\\
	+Delete(entity : T) : void\\
	+GetAll() : IEnumerable<T>\\
	+GetById(id : int) : T\\
	+EntryCount() : int
}

\end{umlpackage}


\umlimpl{ISolution}{IEntity}
\umlimpl{Solution}{ISolution}
\umlimpl[geometry=|-|]{Period}{IEntity}
\umlimpl[geometry=|-|]{Examination}{IEntity}
\umlimpl[geometry=|-|]{Room}{IEntity}
\umlimpl[geometry=-|]{PeriodHardConstraint}{IEntity}
\umlimpl[geometry=-|]{RoomHardConstraint}{IEntity}
\umlimpl[geometry=-|]{InstitutionalModelWeightings}{IEntity}
\umlimpl{Repository<T>}{IRepository<T>}
\end{tikzpicture}

\caption{Data Access Layer} \label{fig:DataAccessLayer}
\end{figure}

\subsection{Business Layer}
\label{subsec:BussinessLayer}

The \gls{bl} provides access to the repositories explained above by, in each of the business classes, affording CRUD functions or get/set functions, and specific functions that depend on the type of the repository. One example of these last functions is, considering the room hard constraints repository, is to get all the room hard constraints that is of a certain type. This can be seen in the Figure \ref{fig:BusinessLayer}, which includes all the \gls{bl} classes, methods and variables. The CRUD functions provided by some of the business classes simply use the CRUD functions from the Repository instance, which is presented on that same business class.\\

Business classes afford CRUD functions if the objective is to store multiple instances of a certain type of entity. If that's the case, it uses a Repository instance of that type of entity. Thus, business classes that only store one instance, do not provide CRUD functions, just a \textit{set} and \textit{get} function. This makes sense, considering it only stores one instance of an entity, instead of multiple entity instances, not needing the use of a Repository. One example of these classes is the ConflictMatrix. \\

The ConflictMatrix provides the number of conflicts of each pair of examinations. Even though it's not an entity that implements IEntity, it must be easily accessed in the lower layers. There's only one instance of this class because there's only one conflict matrix for each set. Each set must be loaded using the Loader if that set is to be tested.\\

All the business classes implement the Singleton pattern. This decision was made because it makes sense to keep only one repository of each entity since they must be populated using the Loader each time a set is tested. Another reason is to avoid passing the instances references of the business classes to all the heuristics and tools that use them, and so, the instances can be easily be accessed statically.\\

\begin{figure}[t!]
\centering

\begin{tikzpicture}

\begin{umlpackage}[y=-6]{Business Layer} 
\umlclass[x = -2, y= -14]{PeriodHardConstraints}
{
	\umlstatic{\#instance : PeriodHardConstraints}\\
	-phc\_repo : IRepository<PeriodHardConstraint>
}
{
	\umlstatic{+Instance() : PeriodHardConstraints}\\
	\umlstatic{+Kill() : void}
	+Insert(phc : PeriodHardConstraint) : void\\
	+Delete(phc : PeriodHardConstraint) : void\\
	+GetAll() : IEnumerable<PeriodHardConstraint>\\
	+GetById(id : int) : PeriodHardConstraint\\
	+GetByType(type : PeriodHardConstraint.types) :\\ IEnumerable<PeriodHardConstraint>\\
	+GetByTypeWithExamId(type : PeriodHardConstraint.types, \\
	exam\_id : int) : IEnumerable<PeriodHardConstraint>\\
	+GetExamsWithChainingCoincidence(exam\_id : int) :\\ IEnumerable<int>\\
	-GetExamsWithChainingCoincidenceAux(exams : \\
	List<int>) : void
}
\umlclass[x = 5, y = -8.2]{Solutions}
{
	\umlstatic{\#instance : Solutions}\\
	-solutions\_repo : IRepository<Solution>
}
{
	\umlstatic{+Instance() : Solutions}\\
	\umlstatic{+Kill() : void}
	+Insert(solution : Solution) : void\\
	+Delete(solution : Solution) : void\\
	+GetAll() : IEnumerable<Solution>\\
	+GetById(id : int) : Solution
}

\umlclass[x = -3, y = 0]{Periods}
{
	\umlstatic{\#instance : Periods}\\
	-periods\_repo : IRepository<Period>
}
{
	\umlstatic{+Instance() : Periods}\\
	\umlstatic{+Kill() : void}\\
	+Insert(period : Period) : void\\
	+Delete(period : Period) : void\\
	+GetAll() : IEnumerable<Period>\\
	+GetById(id : int) : Period\\
	+EntryCount() : int
}

\umlclass[x = 6, y=-12]{ConflictMatrix}
{
	\umlstatic{\#instance : ConflictMatrix}\\
	-conflict\_matrix : int[,]
}
{
	\umlstatic{+Instance() : ConflictMatrix}\\
	\umlstatic{+Kill() : void}\\
	+Get() : int[,]\\
	+Set(conflict\_matrix : int[,]) : void
}

\umlclass[x = 5, y = -4.3]{ModelWeightings}
{
	\umlstatic{\#instance : ModelWeightings}\\
	-imw : InstitutionalModelWeightings
}
{
	\umlstatic{+Instance() : ModelWeightings}\\
	\umlstatic{+Kill() : void}\\
	+Get() : InstitutionalModelWeightings\\
	+Set(imw : InstitutionalModelWeightings) : void

}

\umlclass[x = 4, y = 0]{Examinations}
{
	\umlstatic{\#instance : Examinations}\\
	-examinations\_repo : IRepository<Examination>
}
{
	\umlstatic{+Instance() : Examinations}\\
	\umlstatic{+Kill() : void}\\
	+Insert(exam : Examination) : void\\
	+Delete(exam : Examination) : void\\
	+GetAll() : IEnumerable<Examination>\\
	+GetById(id : int) : Examination\\
	+EntryCount() : int
}

\umlclass[x = -3, y = -6.5]{RoomHardConstraints}
{
	\umlstatic{\#instance : RoomHardConstraints}\\
	-rhc\_repo : IRepository<RoomHardConstraint>
}
{
	\umlstatic{+Instance() : RoomHardConstraints}\\
	\umlstatic{+Kill() : void}\\
	+Insert(rhc : RoomHardConstraint) : void\\
	+Delete(rhc : RoomHardConstraint) : void\\
	+GetAll() : IEnumerable<RoomHardConstraint>\\
	+GetById(id : int) : RoomHardConstraint\\
	+EntryCount() : int\\
	+HasRoomExclusivity(exam\_id : int) : bool\\
	+GetByType(type : RoomHardConstraint.types) : \\ 					IEnumerable<RoomHardConstraint>
}

\umlclass[x = 6, y = -16.3]{Rooms}
{
	\umlstatic{\#instance : Rooms}\\
	-rooms\_repo : IRepository<Room>
}
{
	\umlstatic{+Instance() : Rooms}\\
	\umlstatic{+Kill() : void}\\
	+Insert(room : Room) : void\\
	+Delete(room : Room) : void\\
	+GetAll() : IEnumerable<Room>\\
	+GetById(id : int) : Room\\
	+EntryCount() : int\\

}
\end{umlpackage}
\end{tikzpicture}
\caption{Business Layer} \label{fig:BusinessLayer}
\end{figure}

\subsection{Tools Layer}
The \gls{tl} represents the layer that contains all the tools used by the \gls{hl} and by the lower layers, while using the \gls{bl} to access all the stored entities. These tools are named EvaluationFunction, Loader, NeighborSelection, FeasibilityTester and OutputFormatting.\\

EvaluationFunction is a tool that allows the computation of the validation, fitness and distance to feasibility for a given solution. A solution is only valid if the examinations are all set, even if the solution is not feasible. The distance to feasibility determines the number of violated hard constraints and the fitness determines the score of the solution depending on the violated soft constraints and its penalty values. The distance to feasibility is used by the \gls{gc} heuristic to guarantee that the end solution is feasible, while the fitness is used by the \gls{sa} to compare the score of the current solution and the generated neighbors.\\

The Loader loads all the information presented in a file SET into the repositories. This tool is the first to be run allowing the heuristics and other tools to use the entities through the repositories. More information about this tool will be given in the {\color{red}section **X**}.\\

The NeighborSelection is a tool that provides functions that verifies if a certain neighbor function can be applied in the current solution, if so, it returns a Neighbor object. A Neighbor object does not represent a neighbor solution, but the changes that need to be applied to the current solution if this neighbor is to be accepted. Details about this tool will be explained in the {\color{red}section **X**}.\\

The FeasibilityTester is a tool that provides functions, which efficiently checks if a certain examination can be placed in a certain period, room or simultaneously period and room. This tool is used by both \gls{gc} and \gls{sa}, even though it only works if the examination to check is not yet set in the solution provided.\\

The OutputFormatting tool is used to create the output file given the final solution. This file obeys the output file rules represented in the \gls{itc2007}'s site \cite{McCollum2007b} in order to be able to submit the solution \cite{McCollum2007c}. Submitting the solution allows to check all violated hard constraints, soft constraints, distance to feasibility and fitness values on the site's page.

\subsection{Heuristics Layer}

The \gls{hl} offers access to all the implemented heuristics. These are the \gls{gc}, \gls{sa}, and \gls{hc}. All these heuristics are used to create the best timetable possible given a limited time. Heuristics like \gls{sa} and \gls{hc} make use of neighbor solutions, and so, utilize the NeighborSelection tool for this effect. They also use tools like FeasibilityTester and EvaluationFunction to help build the initial solution and check the fitness while improving the current solution, respectively.\\

Extensive explanation about these heuristics will be given in the {\color{red}section **X**}.

\subsection{Presentation Layer}

The \gls{pl}, in this phase, works mainly as a debugger to run the all the project functionalities and to check the final results. It's in this layer that all the tests are made, like checking execution timings and changing input parameters on \gls{sa} and \gls{hc} to check if better results can be achieved.\\

It is planned to be implemented by the final phase, another version of the presentation layer that includes the possibility of visualization of the final and best timetable generated.













